// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build go1.5

// validate is a tool to automate the creation of methods that satisfy the fmt.validate
// interface. Given the name of a (signed or unsigned) integer type T that has constants
// defined, validate will create a new self-contained Go source file implementing
//	func (t T) String() string
// The file is created in the same package and directory as the package that defines T.
// It has helpful defaults designed for use with go generate.
//
// validate works best with constants that are consecutive values such as created using iota,
// but creates good code regardless. In the future it might also provide custom support for
// constant sets that are bit patterns.
//
// For example, given this snippet,
//
//	package painkiller
//
//	type Pill int
//
//	const (
//		Placebo Pill = iota
//		Aspirin
//		Ibuprofen
//		Paracetamol
//		Acetaminophen = Paracetamol
//	)
//
// running this command
//
//	validate -type=Pill
//
// in the same directory will create the file pill_string.go, in package painkiller,
// containing a definition of
//
//	func (Pill) String() string
//
// That method will translate the value of a Pill constant to the string representation
// of the respective constant name, so that the call fmt.Print(painkiller.Aspirin) will
// print the string "Aspirin".
//
// Typically this process would be run using go generate, like this:
//
//	//go:generate validate -type=Pill
//
// If multiple constants have the same value, the lexically first matching name will
// be used (in the example, Acetaminophen will print as "Paracetamol").
//
// With no arguments, it processes the package in the current directory.
// Otherwise, the arguments must name a single directory holding a Go package
// or a set of Go source files that represent a single Go package.
//
// The -type flag accepts a comma-separated list of types so a single run can
// generate methods for multiple types. The default output file is t_string.go,
// where t is the lower-cased name of the first type listed. It can be overridden
// with the -output flag.
//
package main // import "github.com/shelakel/go-validate/cmd/validate"

import (
	"bytes"
	"flag"
	"fmt"
	"go/build"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"unicode"
)

var (
	typName       = flag.String("type", "", "type name; must be set")
	customName    = flag.String("name", "", "custom name to be used; optional")
	customImports = flag.String("imports", "", "additional packages to import; comma seperated, optional")
	output        = flag.String("output", "", "output file name; default srcdir/validate_<type>.go")
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\tvalidate [flags] -type T [directory]\n")
	fmt.Fprintf(os.Stderr, "\tvalidate [flags] -type T files... # Must be a single package\n")
	fmt.Fprintf(os.Stderr, "For more information, see:\n")
	fmt.Fprintf(os.Stderr, "\thttp://godoc.org/github.com/shelakel/go-validate/cmd/validate\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("validate: ")
	flag.Usage = Usage
	flag.Parse()
	if len(*typName) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	typeName := *typName
	name := *customName
	imports := buildImports(typeName, strings.Split(*customImports, ","))

	if name == "" {
		if strings.HasPrefix(typeName, "*") {
			name = strings.Title(typeName[1:])
		} else {
			name = strings.Title(typeName)
		}
	}

	buf := bytes.NewBuffer(make([]byte, 0))
	printf := func(format string, a ...interface{}) {
		fmt.Fprintf(buf, format, a...)
	}

	// We accept either one directory or a list of files. Which do we have?
	args := flag.Args()
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}
	var (
		dir string
	)
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}

	pkg, err := build.Default.ImportDir(dir, 0)
	if err != nil {
		log.Printf(err.Error())
		os.Exit(2)
	}

	// Print the header and package clause.
	printf("// Code generated by \"validate %s\"; DO NOT EDIT\n", strings.Join(os.Args[1:], " "))
	printf("\n")
	printf("package %s", pkg.Name)
	printf("\n")

	if len(imports) == 1 {
		printf("import \"%s\"\n", imports[0])
	} else {
		printf("import (\n")
		for _, imp := range imports {
			printf("    \"%s\"\n", imp)
		}
		printf(")\n")
	}
	printf("\n")
	printf("type %sValidator struct {\n", name)
	printf("	errorMessage string\n")
	printf("	params       map[string]interface{}\n")
	printf("	validate     func(%s) bool\n", typeName)
	printf("\n")
	printf("	constParams map[string]interface{}\n")
	printf("	validators  []func(%s) error\n", typeName)
	printf("}\n")
	printf("\n")
	printf("func New%sValidator(params map[string]interface{}) *%sValidator {\n", name, name)
	printf("	return &%sValidator{constParams: params}\n", name)
	printf("}\n")
	printf("\n")
	printf("func (validator *%sValidator) Validate(validate func(%s) bool) *%sValidator {\n", name, typeName, name)
	printf("	validator.validate = validate\n")
	printf("	return validator\n")
	printf("}\n")
	printf("\n")
	printf("func (validator *%sValidator) WithParams(params map[string]interface{}) *%sValidator {\n", name, name)
	printf("	validator.params = params\n")
	printf("	return validator\n")
	printf("}\n")
	printf("\n")
	printf("func (validator *%sValidator) WithErrorMessage(errorMessage string) *%sValidator {\n", name, name)
	printf("	validator.errorMessage = errorMessage\n")
	printf("	return validator\n")
	printf("}\n")
	printf("func (validator *%sValidator) Add() *%sValidator {\n", name, name)
	printf("	if validator.validate != nil {\n")
	printf("		tmpl := template.Must(template.New(\"errorMessage\").Parse(validator.errorMessage))\n")
	printf("		params := make(map[string]interface{})\n")
	printf("		for key, value := range validator.constParams {\n")
	printf("			params[key] = value\n")
	printf("		}\n")
	printf("		for key, value := range validator.params {\n")
	printf("			params[key] = value\n")
	printf("		}\n")
	printf("		isValid := validator.validate\n")
	printf("		validator.validators = append(validator.validators,\n")
	printf("			func(value %s) error {\n", typeName)
	printf("				if isValid(value) {\n")
	printf("					return nil\n")
	printf("				}\n")
	printf("				return FormatErrorMessage(tmpl, params, value)\n")
	printf("			})\n")
	printf("	}\n")
	printf("	validator.errorMessage = \"\"\n")
	printf("	validator.params = nil\n")
	printf("    return validator\n")
	printf("}\n")
	printf("\n")
	printf("func (validator *%sValidator) Build() func(%s) error {\n", name, typeName)
	printf("	validator.Add()\n")
	printf("	validators := validator.validators\n")
	printf("	return func(value %s) error {\n", typeName)
	printf("		for _, validate := range validators {\n")
	printf("			if err := validate(value); err != nil {\n")
	printf("				return err\n")
	printf("			}\n")
	printf("		}\n")
	printf("		return nil\n")
	printf("	}\n")
	printf("}\n")
	printf("\n")
	printf("func (validator *%sValidator) NonZero() *%sValidator {\n", name, name)
	printf("	var zero %s\n", typeName)
	printf("	return validator.Add().Validate(func(value %s) bool { return value != zero }).WithErrorMessage(\"{.Value} must not be a zero value\")\n", typeName)
	printf("}\n")

	customValidations(printf, name, typeName)

	// Format the output.
	src, err := format.Source(buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		log.Printf(err.Error())
		return
	}

	// Write to file.
	outputName := *output
	if outputName == "" {
		baseName := fmt.Sprintf("validate_%s.go", toSnake(name))
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	} else if strings.Contains(outputName, "%s") {
		outputName = fmt.Sprintf(outputName, toSnake(name))
	}
	err = ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func customValidations(printf func(format string, a ...interface{}), name, typeName string) {
	if numericTypes[typeName] {
		printf("\n")
		generateNumericFunctions(printf, name, typeName)
	}
}

func buildImports(typeName string, customImports []string) []string {
	imports := []string{"text/template"}
	for _, imp := range customImports {
		imp = strings.TrimSpace(strings.Trim(imp, "\""))
		if len(imp) > 0 {
			imports = append(imports, imp)
		}
	}
	return imports
}

var numericTypes = map[string]bool{
	"int":     true,
	"int8":    true,
	"int16":   true,
	"int32":   true,
	"int64":   true,
	"byte":    true,
	"uint":    true,
	"uint8":   true,
	"uint16":  true,
	"uint32":  true,
	"uint64":  true,
	"float32": true,
	"float64": true,
}

func generateNumericFunctions(printf func(format string, a ...interface{}), name, typeName string) {
	printf("func (validator *%sValidator) Min(min %s) *%sValidator {\n", name, typeName, name)
	printf("	return validator.Add().Validate(func(value %s) bool { return value >= min }).\n", typeName)
	printf("		WithParams(map[string]interface{}{\"MinValue\": min}).\n")
	printf("		WithErrorMessage(\"{.Value} must be greater than or equal to {.MinValue}\")\n")
	printf("}\n")
	printf("\n")
	printf("func (validator *%sValidator) Max(max %s) *%sValidator {\n", name, typeName, name)
	printf("	return validator.Add().Validate(func(value %s) bool { return value <= max }).\n", typeName)
	printf("		WithParams(map[string]interface{}{\"MaxValue\": max}).\n")
	printf("		WithErrorMessage(\"{.Value} must be less than or equal to {.MaxValue}\")\n")
	printf("}\n")
	printf("\n")
	printf("func (validator *%sValidator) Between(min, max %s) *%sValidator {\n", name, typeName, name)
	printf("	return validator.Add().Validate(func(value %s) bool { return value >= min && value <= max }).\n", typeName)
	printf("		WithParams(map[string]interface{}{\"MinValue\": min, \"MaxValue\": max}).\n")
	printf("		WithErrorMessage(\"{.Value} must be between {.MinValue} and {.MaxValue}\")\n")
	printf("}\n")
}

// isDirectory reports whether the named file is a directory.
func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

func toSnake(in string) string {
	runes := []rune(in)
	length := len(runes)

	var out []rune
	for i := 0; i < length; i++ {
		if i > 0 && unicode.IsUpper(runes[i]) && ((i+1 < length && unicode.IsLower(runes[i+1])) || unicode.IsLower(runes[i-1])) {
			out = append(out, '_')
		}
		out = append(out, unicode.ToLower(runes[i]))
	}

	return string(out)
}
